### How `rememberSaveable` works internally?

First thing fisrt, if you look into the `remember` composable function, it's quite simple:

```kotlin
@Composable
inline fun <T> remember(crossinline calculation: @DisallowComposableCalls () -> T): T =
    currentComposer.cache(false, calculation)
```

It uses cache, that is remember, a value in the composition data of a composition. This is used to implement remember and used by the compiler plugin to generate more efficient calls to remember when it determines these optimizations are safe.

However, if you look into the `rememberSaveable`, it looks much more complicated.

```kotlin
@Composable
fun <T : Any> rememberSaveable(
    vararg inputs: Any?,
    saver: Saver<T, out Any> = autoSaver(),
    key: String? = null,
    init: () -> T
): T {
    val compositeKey = currentCompositeKeyHash
    // key is the one provided by the user or the one generated by the compose runtime
    val finalKey = if (!key.isNullOrEmpty()) {
        key
    } else {
        compositeKey.toString(MaxSupportedRadix)
    }
    @Suppress("UNCHECKED_CAST")
    (saver as Saver<T, Any>)

    val registry = LocalSaveableStateRegistry.current

    val holder = remember {
        // value is restored using the registry or created via [init] lambda
        val restored = registry?.consumeRestored(finalKey)?.let {
            saver.restore(it)
        }
        val finalValue = restored ?: init()
        SaveableHolder(saver, registry, finalKey, finalValue, inputs)
    }

    val value = holder.getValueIfInputsDidntChange(inputs) ?: init()
    SideEffect {
        holder.update(saver, registry, finalKey, value, inputs)
    }

    return value
}
```

So, if you break it down one by one it executes in order below:

1. **Retrieve or Generate a Key:** First, it attempts to retrieve the `key` from the provided parameter. If the parameter is null, it generates a key using the `currentCompositeKeyHash` method, which creates a hash value. This hash is used to map the externally stored state to the composition.

2. **Obtain the SaveableStateRegistry:** Next, it retrieves a static instance of `SaveableStateRegistry` from `LocalSaveableStateRegistry`. This registry allows components to save and restore their state using the saved instance state mechanism.

3. **Create a SaveableHolder:** A `SaveableHolder` instance is then created by consuming the restored value from the `SaveableStateRegistry`. If the restored value is empty, it uses the provided `saver` to restore the state.

4. **Update the SaveableHolder Value:** The value from the `SaveableHolder` instance is retrieved and updated using the provided parameters (`saver`, `registry`, `finalKey`, `value`, `inputs`). This update occurs within `SideEffects`.

5. **Return the Final Value:** Finally, the `value` from the `SaveableHolder` instance is returned.